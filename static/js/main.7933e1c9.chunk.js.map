{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["App","useState","taskStarted","setTaskStarted","videoSrc","setVideoSrc","message","setMessage","inputFile","setInputFile","transcodeOption","setTranscodeOption","ext","setExt","latestLog","setLatestLog","logs","setLogs","doTranscode","a","ffmpeg","createFFmpeg","log","logger","logmsg","load","inputFilename","uuidv4","outputFilename","write","transcode","split","join","data","read","URL","createObjectURL","Blob","buffer","type","useEffect","l","className","src","controls","kind","htmlFor","id","onChange","e","target","files","disabled","name","cols","rows","value","onClick","map","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"kVAqHeA,MAhHf,WAA8B,IAAD,EACWC,oBAAS,GADpB,mBACpBC,EADoB,KACPC,EADO,OAEKF,mBAAS,IAFd,mBAEpBG,EAFoB,KAEVC,EAFU,OAGGJ,mBAAS,4BAHZ,mBAGpBK,EAHoB,KAGXC,EAHW,OAION,mBAAsB,MAJ7B,mBAIpBO,EAJoB,KAITC,EAJS,OAKmBR,mBAAS,yLAL5B,mBAKpBS,EALoB,KAKHC,EALG,OAgBLV,mBAAS,OAhBJ,mBAgBpBW,EAhBoB,KAgBfC,EAhBe,OAiBOZ,mBAAS,IAjBhB,mBAiBpBa,EAjBoB,KAiBTC,EAjBS,OAkBHd,mBAAwB,IAlBrB,mBAkBpBe,EAlBoB,KAkBdC,EAlBc,KAoBrBC,EAAW,uCAAG,kCAAAC,EAAA,6DAClBhB,GAAe,GACTiB,EAASC,uBAAa,CAC1BC,KAAK,EACLC,OAAQ,YAA+C,IAAnCC,EAAkC,EAA3ClB,QACTS,EAAaS,MAGjBP,EAAQ,IACRV,EAAW,0BATO,SAUZa,EAAOK,OAVK,cAWlBlB,EAAW,wBACLmB,EAAgBC,cAChBC,EAbY,UAaQD,cAbR,YAaoBf,GAbpB,UAcZQ,EAAOS,MAAMH,EAAelB,GAdhB,yBAeZY,EAAOU,UACXJ,EACAE,EACAlB,EAAgBqB,MAAM,MAAMC,KAAK,MAlBjB,QAoBlBzB,EACE,+EAEI0B,EAAOb,EAAOc,KAAKN,GACzBvB,EACE8B,IAAIC,gBAAgB,IAAIC,KAAK,CAACJ,EAAKK,QAAS,CAAEC,KAAK,SAAD,OAAW3B,OAzB7C,4CAAH,qDAqCjB,OARA4B,qBAAU,WACU,KAAd1B,GAAkBG,GAAQ,SAACwB,GAAD,4BAAWA,GAAX,CAAc3B,SAC3C,CAACA,IAOF,yBAAK4B,UAAU,OACb,4BACA,2BAAOC,IAAKvC,EAAUwC,UAAQ,GAC5B,2BAAOC,KAAK,SAEd,6BACE,2BAAOC,QAAQ,QACb,2BACEC,GAAG,OACHR,KAAK,OACLS,SAfS,SAACC,GACdA,EAAEC,OAAOC,OAAO1C,EAAawC,EAAEC,OAAOC,MAAM,KAexCC,SAAUlD,MAIhB,6BACA,uDAEE,8BACEmD,KAAK,GACLX,UAAU,mBACVY,KAAM,GACNC,KAAM,GACNC,MAAO9C,EACPsC,SAAU,SAACC,GACTtC,EAAmBsC,EAAEC,OAAOM,UATlC,kBAaE,2BACEjB,KAAK,OACLiB,MAAO5C,EACPoC,SAAU,SAACC,GACTpC,EAAOoC,EAAEC,OAAOM,WAItB,6BACE,4BACEjB,KAAK,SACLkB,QAASvC,EACTkC,UAAW5C,GAAaN,GAH1B,UAQF,2BAAII,GACJ,6BACE,8BAAOU,EAAK0C,KAAI,SAACpC,GAAD,gBAAYA,EAAZ,aCjGJqC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCdNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAaC,gBAEdC,OAAM,SAACC,GACNC,QAAQD,MAAMA,EAAMtE,c","file":"static/js/main.7933e1c9.chunk.js","sourcesContent":["import React, { ReactElement, useEffect, useState } from 'react'\nimport { v4 as uuidv4 } from 'uuid'\nimport { createFFmpeg } from '@ffmpeg/ffmpeg'\nimport './App.css'\n\nfunction App(): ReactElement {\n  const [taskStarted, setTaskStarted] = useState(false)\n  const [videoSrc, setVideoSrc] = useState('')\n  const [message, setMessage] = useState('Click Start to transcode')\n  const [inputFile, setInputFile] = useState<null | File>(null)\n  const [transcodeOption, setTranscodeOption] = useState(\n    `-threads 8\n-vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2\"\n-pix_fmt yuv420p\n-strict experimental\n-r 30\n-acodec aac\n-ar 44100 -ac 2\n-vb 1024k\n-minrate 1024k -maxrate 1024k -bufsize 1024k`\n  )\n  const [ext, setExt] = useState('mp4')\n  const [latestLog, setLatestLog] = useState('')\n  const [logs, setLogs] = useState<Array<string>>([])\n\n  const doTranscode = async () => {\n    setTaskStarted(true)\n    const ffmpeg = createFFmpeg({\n      log: true,\n      logger: ({ message: logmsg }: { message: string }) => {\n        setLatestLog(logmsg)\n      },\n    })\n    setLogs([])\n    setMessage('Loading ffmpeg-core.js')\n    await ffmpeg.load()\n    setMessage('Start transcoding...')\n    const inputFilename = uuidv4()\n    const outputFilename = `${uuidv4()}.${ext}`\n    await ffmpeg.write(inputFilename, inputFile)\n    await ffmpeg.transcode(\n      inputFilename,\n      outputFilename,\n      transcodeOption.split('\\n').join(' ')\n    )\n    setMessage(\n      'Complete transcoding! If need more transcoding, you should reload this page'\n    )\n    const data = ffmpeg.read(outputFilename)\n    setVideoSrc(\n      URL.createObjectURL(new Blob([data.buffer], { type: `video/${ext}` }))\n    )\n  }\n\n  useEffect(() => {\n    if (latestLog !== '') setLogs((l) => [...l, latestLog])\n  }, [latestLog])\n\n  const handleFile = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) setInputFile(e.target.files[0])\n  }\n\n  return (\n    <div className=\"App\">\n      <p />\n      <video src={videoSrc} controls>\n        <track kind=\"cap\" />\n      </video>\n      <div>\n        <label htmlFor=\"file\">\n          <input\n            id=\"file\"\n            type=\"file\"\n            onChange={handleFile}\n            disabled={taskStarted}\n          />\n        </label>\n      </div>\n      <br />\n      <div>\n        ffmpeg -i inputFile&nbsp;\n        <textarea\n          name=\"\"\n          className=\"transcode-option\"\n          cols={45}\n          rows={10}\n          value={transcodeOption}\n          onChange={(e) => {\n            setTranscodeOption(e.target.value)\n          }}\n        />\n        &nbsp;outputFile.\n        <input\n          type=\"text\"\n          value={ext}\n          onChange={(e) => {\n            setExt(e.target.value)\n          }}\n        />\n      </div>\n      <div>\n        <button\n          type=\"button\"\n          onClick={doTranscode}\n          disabled={!inputFile || taskStarted}\n        >\n          Start\n        </button>\n      </div>\n      <p>{message}</p>\n      <pre>\n        <code>{logs.map((log) => `${log}\\n`)}</code>\n      </pre>\n    </div>\n  )\n}\n\nexport default App\n","/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/no-use-before-define */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config): void {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      // eslint-disable-next-line no-param-reassign\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister(): void {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}